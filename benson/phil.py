import benson.magic as METHODS
from pydantic import BaseModel
from benson import ImputationGrid
from benson.magic import Magic
import importlib
import warnings
from sklearn.exceptions import ConvergenceWarning


from benson.gallery import GridGallery,MagicGallery
from sklearn.experimental import enable_iterative_imputer
from sklearn.impute import IterativeImputer
from itertools import product

import pandas as pd
import numpy as np

from typing import List,Tuple

class Phil:
    """
    Phil your missing data with confidence! Avoid analysis paralysis by combining scikit-learn's IterativeImputer with topological methods to handle hundreds of possible versions of your data with ease.
    """
    
    def __init__(self, param_grid="default", magic="ECT", config=None, random_state=None):
        
        self.config, self.magic = self._configure_magic_method(magic=magic, config=config)
        self.param_grid = self._configure_param_grid(param_grid)
        
        # Set the random state
        self.random_state = random_state

        # Initialize representations and descriptors
        self.representations = []
        self.magic_descriptors = []

    def impute(self, df:pd.DataFrame,max_iter:int=10)-> List[pd.DataFrame]:
        """
        Runs IterativeImputer over all parameter combinations and returns a list of imputed DataFrames.

        Parameters
        ----------
        df : pandas.DataFrame
            DataFrame with missing values.

        Returns
        -------
        list of tuple
            A list of tuples (params, imputed_df), where `params` is a dictionary of parameters used,
            and `imputed_df` is the imputed DataFrame.
        """
        results = []
        methods = self.param_grid.methods
        modules = self.param_grid.modules
        grids = self.param_grid.grids
        
        imputers = []
        for method, module, params in zip(methods, modules, grids):
            imported_module = importlib.import_module(module)
            model = getattr(imported_module, method)
            for param_vals in params:
                compatible_params = {k: v for k, v in param_vals.items() if k in model.__init__.__code__.co_varnames}
                estimator = model(**compatible_params)
                imputer = IterativeImputer(estimator, random_state=self.random_state, max_iter=max_iter)
                imputers.append(imputer)
    
        
        # pass imputer list to IterativeImputer
        with warnings.catch_warnings():
                warnings.filterwarnings("ignore", category=ConvergenceWarning)
                results = [imputer.fit_transform(df) for imputer in imputers]
        return results

    def generate_representations(self)-> List[np.ndarray]:
        """
        Generates representations using the magic method.

        Parameters
        ----------
        df : pandas.DataFrame
            DataFrame to generate representations for.
        device : str, optional
            Device to use for computation. Default is 'cpu'.

        Returns
        -------
        list
            List of representations generated by the magic method.
        """

        return [self.magic.generate(imputed_df) for imputed_df in self.representations]

    def fit_transform(self, df:pd.DataFrame,max_iter:int=5)->pd.DataFrame:
        """
        Imputes missing data, generates representations, and selects the best representation.

        Parameters
        ----------
        df : pandas.DataFrame
            DataFrame with missing values.
        device : str, optional
            Device to use for computation. Default is 'cpu'.

        Returns
        -------
        tuple
            A tuple (params, imputed_df) representing the best imputation parameters and the corresponding DataFrame.
        """
        self.representations = self.impute(df,max_iter)
        self.magic_descriptors = self.generate_representations()

        self.closest_index = self._select_representative(self.magic_descriptors)
        return self.representations[self.closest_index]

    def _select_representative(self, descriptors:List[np.ndarray]) -> int:
        """
        Selects the representation closest to the average topological descriptor (i.e. the output of a 'magic' method).

        Parameters
        ----------
        descriptors : list of numpy.ndarray
            List of descriptors.

        Returns
        -------
        int
            Index of the closest representation.
        """
        avg_descriptor = np.mean(descriptors, axis=0)
        closest_index = np.argmin([np.linalg.norm(descriptor - avg_descriptor) for descriptor in descriptors])
        return closest_index
    
    
    def _compute_representation_variability(self,descriptors:List) -> float:
        """
        Computes the variability of the representations.

        Parameters
        ----------
        descriptors : list
            List of representations.

        Returns
        -------
        float
            Variability of the representations.
        """
        return np.var(descriptors)

    @staticmethod
    def _configure_magic_method(magic: str, config) -> Tuple[BaseModel,Magic]:
        """
        Configures the magic method based on the magic string and configuration dictionary.

        Parameters
        ----------
        magic : str
            The name of the magic method to use.
        config : dict
            Configuration dictionary for the magic method.

        Returns
        -------
        tuple
            A tuple containing the configuration and the magic method instance.
        """
        # Retrieve the magic method
        magic_method = getattr(METHODS, magic, None)
        if magic_method is None:
            raise ValueError(f"Magic method '{magic}' not found in the magic submodule. "
                             f"Defaulting to Euler Characteristic Transform (ECT).")
        
        # Retrieve or validate the configuration
        if not isinstance(config, BaseModel):
            config = MagicGallery.get(magic)
        
        magic_instance = magic_method(config=config)
        return config, magic_instance
    


    
    def _configure_param_grid(self, param_grid) -> ImputationGrid:
        """
        Configures the parameter grid based on the parameter grid string or BaseModel.

        Parameters
        ----------
        param_grid : str or BaseModel
            The parameter grid identifier or configuration.

        Returns
        -------
        dict
            Dictionary of parameter grid values.
        """
        if isinstance(param_grid, str):
            return GridGallery.get(param_grid)
        if isinstance(param_grid, BaseModel):
            return param_grid.model_dump()
        raise ValueError("Invalid parameter grid type. Must be a string or a BaseModel instance.")



if __name__ == "__main__":
    # Example usage
    from sklearn.datasets import load_iris, load_diabetes, load_breast_cancer, load_wine, load_digits, load_linnerud
    import time
    
    #Load all datasets into a list
    datasets = [load_iris(), load_diabetes(), load_breast_cancer(), load_wine(), load_digits(), load_linnerud()]
    for D in datasets:
        df = pd.DataFrame(D.data, columns=D.feature_names)
        print(f"Dataset shape: {df.shape}")
        # Randomly remove entries from the DataFrame
        np.random.seed(42)  # For reproducibility
        mask = np.random.rand(*df.shape) < 0.2  # 20% missing values
        df[mask] = np.nan

        phil = Phil()
        
        start = time.time()
        best_imputed = phil.fit_transform(df)
        print(df.head())
        print("Variability of representations:", phil._compute_representation_variability(phil.representations))
        print(f"Time taken to compute and analyze {len(phil.representations)} representations:", time.time()-start)
        print()
        
    
    